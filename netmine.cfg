# config version format
version = 1.1;

permissions :
{
   username = "coinscope";
   group = "coinscope";
}

logger:
{
   root = "/tmp/logger/";
   max_buffer = 524288000; #will disconnect reader clients if buffer is larger than this, in bytes
};

verbatim:
{
  logpath = "/var/log/coinscope/"; # You can set up verbatim to work with logrotate, which you probably want.
};

getaddr: {
  # getaddr will reinitiate in the product of hour and minutes list
  # TODO: just copy cron format
  schedule: { # in system local time ...
    hours = ( 0, 4, 8, 12, 16, 20 );
    minutes = ( 15 );
  };
  ports = ( 8333, 8334 ); # make this an empty list to accept all ports, otherwise this is a whitelist of what to accept
  sampling_rate = .1; # probability of a address in addr of being sampled
};

ground_ctrl:
{
   control_path = "/tmp/connector/gc_ctrl"; # control socket where GC multiplexes to children
   control_listen = 5; # Argument to listen parameter for control sock
};

connector:
{
   # This should ALWAYS just duplicate what is in the ground_ctrl
   # setting. It is not respected by the connector, but old clients
   # may read it and therefore, it may be convenient to leave it
   # here. If you don't use a client that does this, it can be
   # deleted. If you only use one connector, it would be connector 0
   # in the connectors list and it would be easier to just duplicate
   # its path here
   control_path = "/tmp/connector/gc_ctrl"; 
}

connectors:
{
   msg_pool_size = 128; # How many registered messages should be kept

   # addresses to relay in the "active ping". All connectors broadcast
   # the same address here. Right now it chooses a choice from the
   # list randomly, but never revists its choice, so the list ought to
   # only have one item in it. If broadcasting multiple addresses (for
   # incoming guys) is necessary we can modify the code to cycle
   # through.
   broadcast = ( ( "AF_INET", "127.0.0.1", 8334 ) );

   # NOTE: verify the code actually reads these!
   max_version = 70002;
   min_version = 209;
   services = 1;

   blacklist = "/etc/netmine/blacklist.txt"; # one ip address per line in ascii
   user_agent = "/Coinscope-GH:0.2/";

   # How often should each connection be pinged if we've received
   # no activity. 0 means never.
   bitcoin: {
      # What start height should we send in version messages initially
      start_height = 346110;
      magic = 0xD9B4BEF9L;
      ping_frequency = 0; 
      active_ping: { # How often should each connection be pinged regardless
          mean = 60.0; # These have to be floating point values
          stddev = 1.0;
      };
   };

   instances = ( # connectors take their id by their place on this list.
      {
         control_path = "/tmp/connector/connector.0.ctrl";
         control_listen = 5; # Argument to listen parameter for control sock
         bitcoin: {
            # It will listen to the following list of addresses
            # tuples. Note, currently only AF_INET is supported. No check is
            # done to verify that these make sense, other than to try to
            # connect to them. Format is ("family", "ipv4 addr", port,
            # listeners)
            listeners = ( ( "AF_INET", "127.0.0.1", 8335, 128) ); # change to local interface
         };  
      },
      {
         control_path = "/tmp/connector/connector.1.ctrl";
         control_listen = 5; # Argument to listen parameter for control sock
         bitcoin: {
            # It will listen to the following list of addresses
            # tuples. Note, currently only AF_INET is supported. No check is
            # done to verify that these make sense, other than to try to
            # connect to them. Format is ("family", "ipv4 addr", port,
            # listeners)
            listeners = ( ( "AF_INET", "127.0.0.1", 8334, 128) ); # change to local interface
         };  
      }
   );
};

